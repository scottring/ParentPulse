/**
 * Onboarding Wizard Types
 *
 * Types for the manual onboarding wizard flow, including
 * wizard state, user answers, and generated content
 */

import { RelationshipType, RoleTrigger, RoleStrategy, RoleBoundary } from './person-manual';

// ==================== Wizard State Types ====================

export type WizardStep =
  | 'welcome'
  | 'questions'
  | 'processing'
  | 'review'
  | 'complete';

export interface WizardState {
  currentStep: WizardStep;
  currentSectionIndex: number;
  totalSections: number;
  answers: WizardAnswers;
  generatedContent: GeneratedManualContent | null;
  error: string | null;
  isLoading: boolean;
}

// ==================== Answer Types ====================

export interface SectionAnswers {
  [questionId: string]: string;
}

export interface WizardAnswers {
  overview?: SectionAnswers;
  triggers?: SectionAnswers;
  whatWorks?: SectionAnswers;
  boundaries?: SectionAnswers;
  strengths?: SectionAnswers;
  // Relationship-specific sections
  development?: SectionAnswers;
  loveLanguages?: SectionAnswers;
  health?: SectionAnswers;
  connection?: SectionAnswers;
  workStyle?: SectionAnswers;
  dynamics?: SectionAnswers;
}

// ==================== Generated Content Types ====================

/**
 * Content generated by AI from user's answers
 */
export interface GeneratedManualContent {
  // Role-specific overview (collaborative description for this role)
  roleOverview?: string;

  // General overview section
  overview?: {
    likes: string[];
    dislikes: string[];
    motivations: string[];
    comfortFactors: string[];
    discomfortFactors: string[];
  };

  // Universal sections
  triggers: GeneratedTrigger[];
  whatWorks: GeneratedStrategy[];
  whatDoesntWork: GeneratedStrategy[];
  boundaries: GeneratedBoundary[];
  strengths: string[];
  challenges: string[];
  importantContext: string[];

  // Relationship-specific content
  relationshipSpecific?: {
    // Child
    learningStyle?: string;
    developmentalConsiderations?: string[];

    // Spouse
    loveLanguages?: string[];
    conflictApproach?: string;

    // Elderly Parent
    healthConditions?: string[];
    carePreferences?: string[];

    // Friend
    connectionPreferences?: string[];
    topicsToRemember?: string[];

    // Professional
    workPreferences?: string[];
    collaborationStyle?: string;

    // Sibling
    relationshipDynamics?: string;
    currentContext?: string[];
  };
}

/**
 * Generated trigger before being converted to RoleTrigger
 */
export interface GeneratedTrigger {
  description: string;
  context: string;
  typicalResponse: string;
  deescalationStrategy?: string;
  severity: 'mild' | 'moderate' | 'significant';
}

/**
 * Generated strategy before being converted to RoleStrategy
 */
export interface GeneratedStrategy {
  description: string;
  context: string;
  effectiveness?: 1 | 2 | 3 | 4 | 5;
  notes?: string;
}

/**
 * Generated boundary before being converted to RoleBoundary
 */
export interface GeneratedBoundary {
  description: string;
  category: 'immovable' | 'negotiable' | 'preference';
  context?: string;
  consequences?: string;
}

// ==================== Review/Edit Types ====================

/**
 * Editable item in the review step
 */
export interface EditableContentItem {
  id: string;
  type: 'trigger' | 'strategy' | 'boundary' | 'strength' | 'challenge' | 'context' | 'overview';
  content: GeneratedTrigger | GeneratedStrategy | GeneratedBoundary | string;
  isEditing: boolean;
  isMarkedForDeletion: boolean;
}

/**
 * State for the review step
 */
export interface ReviewState {
  items: {
    overview: EditableContentItem[];
    triggers: EditableContentItem[];
    whatWorks: EditableContentItem[];
    whatDoesntWork: EditableContentItem[];
    boundaries: EditableContentItem[];
    strengths: EditableContentItem[];
    challenges: EditableContentItem[];
    importantContext: EditableContentItem[];
  };
}

// ==================== API Types ====================

/**
 * Request to generate initial manual content
 */
export interface GenerateManualContentRequest {
  familyId: string;
  personId: string;
  personName: string;
  relationshipType: RelationshipType;
  answers: WizardAnswers;
}

/**
 * Response from content generation API
 */
export interface GenerateManualContentResponse {
  success: boolean;
  content?: GeneratedManualContent;
  error?: string;
  errorDetails?: string;
}

// ==================== Progress Tracking ====================

/**
 * Progress saved to localStorage for resume functionality
 */
export interface OnboardingProgress {
  personId: string;
  manualId: string;
  relationshipType: RelationshipType;
  currentStep: WizardStep;
  currentSectionIndex: number;
  answers: WizardAnswers;
  timestamp: number; // Unix timestamp
}

/**
 * Get localStorage key for onboarding progress
 */
export function getOnboardingProgressKey(personId: string): string {
  return `onboarding_progress_${personId}`;
}

/**
 * Save onboarding progress to localStorage
 */
export function saveOnboardingProgress(progress: OnboardingProgress): void {
  const key = getOnboardingProgressKey(progress.personId);
  localStorage.setItem(key, JSON.stringify(progress));
}

/**
 * Load onboarding progress from localStorage
 */
export function loadOnboardingProgress(personId: string): OnboardingProgress | null {
  const key = getOnboardingProgressKey(personId);
  const saved = localStorage.getItem(key);

  if (!saved) return null;

  try {
    const progress = JSON.parse(saved) as OnboardingProgress;

    // Check if progress is stale (older than 7 days)
    const now = Date.now();
    const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);

    if (progress.timestamp < sevenDaysAgo) {
      clearOnboardingProgress(personId);
      return null;
    }

    return progress;
  } catch (error) {
    console.error('Error loading onboarding progress:', error);
    return null;
  }
}

/**
 * Clear onboarding progress from localStorage
 */
export function clearOnboardingProgress(personId: string): void {
  const key = getOnboardingProgressKey(personId);
  localStorage.removeItem(key);
}

// ==================== Validation ====================

/**
 * Check if an answer is valid (not empty or whitespace)
 */
export function isValidAnswer(answer: string | undefined): boolean {
  return !!answer && answer.trim().length > 0;
}

/**
 * Check if a section has at least one required question answered
 */
export function isSectionComplete(
  answers: SectionAnswers,
  requiredQuestionIds: string[]
): boolean {
  return requiredQuestionIds.some(id => isValidAnswer(answers[id]));
}

/**
 * Get percentage of questions answered in wizard
 */
export function getCompletionPercentage(
  answers: WizardAnswers,
  totalQuestions: number
): number {
  const answeredCount = Object.values(answers).reduce((count, sectionAnswers) => {
    return count + Object.values(sectionAnswers).filter(isValidAnswer).length;
  }, 0);

  return totalQuestions > 0 ? Math.round((answeredCount / totalQuestions) * 100) : 0;
}
